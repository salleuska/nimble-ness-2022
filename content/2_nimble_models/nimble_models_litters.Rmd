---
title: "Introduction to NIMBLE"
subtitle: "NIMBLE NESS 2022 short course"
author: "NIMBLE Development Team"
date: "May 2022"
# output:
#   slidy_presentation: default
#   beamer_presentation: default
output:
  xaringan::moon_reader:
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---

```{r setup, include=FALSE}
library(nimble)
has_ggplot2 <- require(ggplot2)
has_mcmcplots <- require(mcmcplots)
has_coda <- require(coda)
generate_original_results <- FALSE

ggplot2::theme_set(theme_bw())
knitr::opts_chunk$set(tidy.opts = list(width.cutoff = 60), tidy = TRUE)

```

---
# How NIMBLE is the same as BUGS and JAGS

* Most distributions and functions are supported

    - For distributions, see [User Manual Section 5.2.4](http://r-nimble.org/manuals/NimbleUserManual.pdf#page=39)
    - For functions, see  [User Manual Section 5.2.5](http://r-nimble.org/manuals/NimbleUserManual.pdf#page=44)
  
* Most syntax is supported

    - Truncation syntax is different when using `nimbleCode`.  (It can
      be the same as for JAGS if reading code from a file with `readBUGSmodel()`).

See our [guide online](https://r-nimble.org/quick-guide-for-converting-from-jags-or-bugs-to-nimble).

---
# How NIMBLE extends BUGS

  - Alternative distribution parameterizations (like R).
  - Named parameters (like R).
  - Vectorized math (e.g., `pred[1:5] <- b0 + b1*x[1:5]`) and linear algebra.
  - Definition-time if-then-else (multiple model variants from the same code).
  - User-defined functions and distributions.
  - Distinction between `constants` and `data`.

### How NIMBLE is limited compared to BUGS and/or JAGS:

NIMBLE is stricter about requiring square brackets and
   informative indices for non-scalar nodes.

---

# R-like alternative and named parameters

Note named parameters in distributions.

```{r, litters-model-param, eval=FALSE}

littersCode <- nimbleCode({
  for (i in 1:G) {
     for (j in 1:N) {
      # likelihood (data model)
        r[i,j] ~ dbin(p[i,j], n[i,j])
  # latent process (random effects)
        p[i,j] ~ dbeta(a[i], b[i]) 
     }
     # prior for hyperparameters
     a[i] ~ dgamma(shape = 1, rate = .001)
     b[i] ~ dgamma(shape = 1, scale = 1/.001)
   }
})
```

Note that we could have used the mean/sd parameterization of the beta distribution, which would then require different hyperparameter specification.

- BUGS/JAGS: Only `dnorm(mu, tau)` is supported, where `tau` is precision.
- NIMBLE: Alternative parameterizations and named parameters are supported:

    - `dnorm(mean = mu, sd = sigma)`
    - `dnorm(mean = mu, var = sigma_squared)`
    - `dnorm(mean = mu, tau = phi)` 
    
- Distributions with alternative parameterizations are listed in Table 5.2 of [User Manual Section 5.2.4](https://r-nimble.org/html_manual/cha-writing-models.html#subsec:dists-and-functions)

---
## What are constants? What are data?

### Constants are values needed to define model relationships

 - Index ranges like *N* in the litters model
 - Constant vectors used for indexing: e.g., *block* in `mu[block[i]]`
 - Constants must be provided when creating a model with `nimbleModel`.

### Data represents a flag on the role a node plays in the model

- E.g., data nodes shouldn't be sampled in MCMC.
- Data values can be changed.
- Data can be provided when calling `nimbleModel` or later.

--
Here's an example:

```{r, data-example}
if(!exists('littersModel'))
    source('chunks_litters.R')
littersModel$isData('r')
littersModel$isData('p')
littersModel$r
littersModel$p
littersModel$simulate('r')
littersModel$simulate('p')
littersModel$r
littersModel$p
littersModel$simulate('r', includeData = TRUE)
littersModel$r
```
---
### Providing data and constants together.

- Data and constants can be provided together **as `constants`**.
- It would be slightly easier for BUGS/JAGS users to call this "data", but that would blur the concepts.  
- NIMBLE will usually disambiguate data when it is provided as constants.

--
### What are covariates and other non-parameters/non-observations?

- Covariates/predictors are examples of values that are not parameters nor data in the sense of the likelihood.
- Covariates/predictors can be provided via `constants` if you don't need to change them (often the case).
- Covariates/predictors can be provided via `data` or `inits` if you want to change them.
- NIMBLE will not treat them as 'data nodes'.
---
# Indexing

When values are grouped (particularly in irregular ways), we often have (potentially complicated) indexing.

Here `sex` and `farm_ids` are vectors of  membership indexes that are known in advance. Make sure to provide them in `constants` to avoid unnecessary computation (more later). 

```{r, eval=FALSE}
for(i in 1:num_animals) {
  logit(disease_probability[i]) <- 
    sex_int[ sex[i] ] +
    length_coef[ sex[i] ] * length[i] +
    farm_effect[ farm_ids[i] ]
  Ecervi_01[i] ~ dbern(disease_probability[i])
}
```

Particularly in ecological models, indexing can get very complicated.

---

The farm grouping above is 'ragged' (as is the sex grouping). If the number of observations per farm were constant ('regular'/'rectangular'), we could have something like this (ignoring sex and length):

```{r, eval=FALSE}
for(j in 1:num_farms) 
  for(i in 1:num_animals_per_farm) {
    logit(disease_probability[j, i]) <- farm_effect[j]
    Ecervi_01[j, i] ~ dbern(disease_probability[j, i])
  }
```

---
# More explicit need to provide dimensions (in models, not in nimbleFunctions)

- Square brackets must always be provided to indicate number of dimensions

    - If `x` is 2-dimensional, use `x[,] %*% beta[]`, not `x %*% beta`
    
* Sometimes NIMBLE is not as smart as BUGS/JAGS at determining dimensions.  There are two solutions:

    * Give dimensions explicitly: `x[1:n, 1:m]`, OR
    * Provide a `dimensions` argument to `nimbleModel`.  Example: `dimensions = list(x = c(n, m))`.

---

# Vectorized math and linear algebra

Instead of writing this in your model code:

```{r, vectorized-1}
nimbleOptions(verbose = FALSE)
m1 <- nimbleModel(
    nimbleCode({
        for(i in 1:5) {
            predicted[i] <- beta0 + beta1 * x[i]
        }
    }
    ))
```
you can write this:
```{r, vectorized-2}
m2 <- nimbleModel(
    nimbleCode({
        predicted[1:5] <- beta0 + beta1 * x[1:5]
    }
    ))
```

They are not equivalent:
```{r, vectorized-3}
## m1 has 5 scalar nodes
m1$getNodeNames()
## m2 has 1 vector node
m2$getNodeNames()
```

One is not necessarily better than the other.  It depends on the model
and the MCMC configuration.  (More on those topics later.)

Vectorized declarations do not work for distributions.

---

# Be careful about scalar vs. vector vs. matrix vs. array

This will not work:
```{r eval = FALSE}
x[1:5] <- A[1:5, 1:5] %*% b[1:5] + c[1:5]
```

The problem is that the right-hand-side returns a matrix, so we can't assign it to a vector.

This will work:
```{r eval = FALSE}
x[1:5] <- (A[1:5, 1:5] %*% b[1:5] + c[1:5])[,1]
```

---
# Definition-time if-then-else

If you wish to define multiple alternative models in one set of code,
you can use if-then-else statements.  These will be evaluated based on
variables in the R environment when the model is defined. **You cannot
use if statements as statements within model code apart from this usage
of defining alternative models.**

For example:

```{r if-then-else}
code <- nimbleCode({
    sigma ~ dunif(0, 10)
    beta0 ~ dnorm(0, sd = 1000)
    beta1 ~ dnorm(0, sd = 1000)
    if(INCLUDE_X2) { beta2 ~ dnorm(0, sd = 1000) } else {}
    for(i in 1:10) {
        if(INCLUDE_X2) {
            y[i] ~ dnorm(beta0 + beta1 * x1[i] + beta2 * x2[i], sd = sigma)
        } else {
            y[i] ~ dnorm(beta0 + beta1 * x1[i], sd = sigma)
        }
    }
})

INCLUDE_X2 <- FALSE
m1 <- nimbleModel(code)
INCLUDE_X2 <- TRUE
m2 <- nimbleModel(code)
m1$getNodeNames()
m2$getNodeNames()

```

m2 has `beta2` while m1 does not.  The long names are "lifted nodes" -- more on those later.

---

### Models are graphs

- Scientists in many application domains and many statisticians speak of "hierarchical models".

- Computer scientists and others sometimes speak of "graphical models".

- A hierarchical model is typically a directed acyclic graph (DAG).

---
### NIMBLE models as objects

When you create a NIMBLE model, it is an object in R.

You can:

 - Get or set parameter or data values.
 - Determine graph relationships.
 - Calculate log probabilities.
 - Simulate (draw) from distributions.
 - More.

---
# Linear regression example

Let's use a really simple model:

- Linear regression with 4 data points.

```{r}
set.seed(1)
code <- nimbleCode({
  intercept ~ dnorm(0, sd = 1000)
  slope ~ dnorm(0, sd = 1000)
  sigma ~ dunif(0, 100)
  for(i in 1:4) {
    predicted.y[i] <- intercept + slope * x[i]
    y[i] ~ dnorm(predicted.y[i], sd = sigma)
  }
})
model <- nimbleModel(code, 
                     data = list(y = rnorm(4)),
                     inits = list(intercept = 0.5, 
                                  slope = 0.2, 
                                  sigma = 1,
                                  x = c(0.1, 0.2, 0.3, 0.4)))
```

`x` values are neither observations ('data') nor parameters. `x` can also be provided in `constants` (this is generally best, unless you plan to change `x`) or in `data` (for consistency with WinBUGS/JAGS).

---
## Draw the graph

This was done with package `igraph`.
```{r, linmodel-graph, echo = FALSE}
layout <- matrix(ncol = 2, byrow = TRUE,
   # These seem to be rescaled to fit in the plot area,
   # so I'll just use 0-100 as the scale
                 data = c(33, 100,
                          66, 100,
                          50, 0, # first three are parameters
                          15, 50, 35, 50, 55, 50, 75, 50, # x's
                          20, 75, 40, 75, 60, 75, 80, 75, # predicted.y's
                          25, 25, 45, 25, 65, 25, 85, 25) # y's
                 )

sizes <- c(45, 30, 30,
           rep(20, 4),
           rep(50, 4),
           rep(20, 4))

edge.color <- "black"
stoch.color <- "deepskyblue2"
det.color <- "orchid3"
rhs.color <- "gray73"
fill.color <- c(
    rep(stoch.color, 3),
    rep(rhs.color, 4),
    rep(det.color, 4),
    rep(stoch.color, 4)
)

plot(model$graph, vertex.shape = "crectangle",
     vertex.size = sizes,
     vertex.size2 = 20,
     layout = layout,
     vertex.label.cex = 1.0,
     vertex.color = fill.color,
     edge.width = 3,
     asp = 0.5,
     edge.color = edge.color)
```

- Think of each line of BUGS language code as declaring one or mode *nodes*.

---
### CHECK ORGANIZATION

 - data: a known quantity in a model, also represented as a random variable, e.g., `r[1,1], r[1,2], ...` in the litters model
 - constants: other fixed quantities involved in the model, e.g., `N` in the litters model
 - node: an element in the model graph representing data, parameter, or a deterministic quantity that is a function of other quantities in the model, e.g. `a[1]`, `a[2]`, and `r[1, 2]` in the litters model
    - nodes can be univariate or multivariate depending on whether they ae defined based on a joint (multivariate) density or joint assignment
 - variable: a collection of one or more nodes with the same name, e.g., 'a' or 'r' in the litters model
---

# Values in the model

What's the current value in a variable?


```{r, model-values}
littersModel$r  
littersModel$a[1]
littersModel$p
```

Setting values:

```{r, model-set-values}
littersModel$a[1] <- 5
littersModel$a
```

---
# Operating the model: *simulate()*
 
We have control over the model. In particular, for every node, NIMBLE provides *calculate()* and *simulate()* functions that calculate the current probability density value for the node and simulate a new value for the node from its (prior) distribution (i.e., given only parent nodes). These operations lie at the heart of many algorithms.

*simulate()* puts new values into the model; if you want to see those values, you need to look into the model.

```{r, model-simulate}
set.seed(1)  # so the calculations are reproducible
littersModel$simulate('p')  # simulate from prior
littersModel$p
littersModel$getLogProb('p')  # log prob not yet updated!
littersModel$calculate('p')   # update it
littersModel$getLogProb('p')  # now we're good
```

---

# Operating the model: *calculate()* 


Let's change values in the model and recalculate the density values. NIMBLE sometimes introduces hidden nodes not specified in the model, so when calculating model density values, it's best to ask NIMBLE to do so based on the dependencies of the altered node.

```{r, model-operate}
littersModel$getLogProb('p')
littersModel$a[1] <- 1
littersModel$b[1] <- 3
littersModel$getLogProb('p')  # recall why this hasn't changed yet

## DON'T DO THIS! (though it's ok to do here...)
## littersModel$calculate('p')

## INSTEAD DO THIS
deps <- littersModel$getDependencies(c('a[1]','b[1]'))
littersModel$calculate(deps)

## alternatively, we could just update the entire model to be safe:
## littersModel$calculate()

## now that model state is updated, can ask for logProbs
littersModel$getLogProb('p')
```
---

# Nodes and variables

The parameters and data in a model are represented as nodes in a graph. Here we define some terms:

 - parameter: an unknown quantity in the model that is represented as a random variable and will generally be estimated in an algorithm, e.g. `mu[1]` in the (reparameterized) litters model
 - data: a known quantity in a model, also represented as a random variable, e.g., `r[1, 1], ..., r[1, 16], ...` in the litters model
 - constants: other fixed quantities involved in the model, e.g., `N` in the litters model
 - node: an element in the model graph representing data, parameter, or a deterministic quantity that is a function of other quantities in the model, e.g., `mu[1]`, `mu[2]`, or `p[1, 5]` in the litters model
     - nodes can be univariate or multivariate depending on whether they are defined based on a univariate or multivariate density (or scalar or vectorized assignment for deterministic nodes)
 - variable: a collection of one or more nodes with the same name, e.g., *mu* or *r* in the litters model. 

# Querying nodes and variables

NIMBLE provides users and programmers with the ability to get information about the nodes and variables in the model and the relationships amongst them.

We can use NIMBLE to ask questions such as:

 - What are the nodes in the model?
 - What are the dependencies of a given node? Note that this is information used in many algorithms.


```{r, model-nodes}
nodes <- model$getNodeNames()
nodes[1:11]
top <- model$getNodeNames(topOnly = TRUE)
top
muDeps <- model$getDependencies('mu')
muDeps[1:11]
```

# Data nodes

```{r, model-data}
model$getNodeNames(dataOnly = TRUE)
model$isData('r')
## parameters (including imputed data)
model$getNodeNames(stochOnly = TRUE, includeData = FALSE)
```

# More details on querying model structure

There are a variety of options to `getNodeNames()` and `getDependencies` that allow you to fine-tune the information you get.

```{r, get-info}
args(model$getDependencies)
args(model$getNodeNames)

latents <- model$getNodeNames(latentOnly = TRUE, stochOnly = TRUE,
        includeData = FALSE)
latents
model$getDependencies(latents, dataOnly = TRUE)
model$getNodeNames(dataOnly = TRUE)
```

# Inspecting the model: variables

What are the variables in the model? What information is available about them?

```{r, model-vars}
model$getVarNames()
model$getVarInfo('mu')
```

As of the current version of NIMBLE, information about
variables is not competely nicely arranged for a user (there aren't as
many query functions), but it is available.

This variable has 1 dimension (`nDim`), and its size is 2 (`maxs`).  Currently `mins` is always 1.  If at least one node within the variable is stochastic, then `anyStoch` will be `TRUE`.


# The importance of querying a model: lifted nodes

You will have noticed a few strangely-named nodes, such as "lifted_mu_oBi_cB_tothe_2_times....", in the model.

NIMBLE implements some features by inserting its own nodes. In this case we reparameterize the model from the mean/sd parameterization of a beta distribution to the shape1/shape2 parameterization, and "lifted_mu_oBi_cB_tothe_2_times..." is the first shape parameter of the beta distribution for the first group.

**You should never assume you know what nodes are in a model simply because you wrote the model code.**

Let's look at the two main ways this happens:

```{r, lifted-1, fig.cap=""}
code <- nimbleCode({
        mu ~ dnorm(0, sd = 10)
        tau ~ dunif(0, 100)
        x ~ dnorm(mu, tau) #by default, tau is a precision
})


m1 <- nimbleModel(code, data = list(x = 2.5), inits = list(mu = 0, tau = 1))

par(mfrow = c(1,1))
plot(m1$getGraph())
m1$getNodeNames()
```
The node `lifted_d1_over_sqrt_oPtau_cP` has been inserted between
`tau` and `x`.   The resulting model would equivalently have been
created by this model code:

```{r, lifted-2, eval = FALSE}
nimbleCode({
    mu ~ dnorm(0, sd = 10)
    tau ~ dunif(0, 100)
    lifted_d1_over_sqrt_oPtau_cP <- 1/sqrt(tau)
    x ~ dnorm(0, sd = lifted_d1_over_sqrt_oPtau_cP) # override and make 2nd arg the SD
})
```

NIMBLE has *lifted* the calculation of standard deviation from
precision so that it is part of the model's graph.  Therefore *you
will make a mistake if you assume that the dependencies of `tau`
include only `x`*:

```{r, bad}
m1$tau                     ## Original value of tau
m1$getParam('x', 'sd')     ## Original value of sd based on tau
m1$tau <- 16
m1$x <- 1
m1$calculate('x') ## Wrong: the lifted node is being neglected
m1$getParam('x', 'sd')     ## Verifying the sd is not up to date.
```

---
# The importance of querying a model: model-generic programming

Instead we need to ask NIMBLE for the dependencies of any nodes that have changed and use *model-generic* programming:


```{r, model-generic}
deps <- m1$getDependencies('tau')
m1$tau <- 16
m1$x <- 1
m1$calculate(deps)    ## Correct: the lifted node is updated too
deps
m1$getLogProb('x')
m1$getParam('x', 'sd')  ## Verifying the sd is up to date
```

So the call to *calculate* causes the lifted node to get updated and then calculates the log probability density for *x*.

