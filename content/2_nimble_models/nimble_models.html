<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>NIMBLE models</title>
    <meta charset="utf-8" />
    <meta name="author" content="NIMBLE Development Team" />
    <script src="libs/header-attrs-2.14/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/tamu-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# NIMBLE models
]
.subtitle[
## NIMBLE NESS 2022 short course
]
.author[
### NIMBLE Development Team
]
.date[
### May 2022
]

---




# NIMBLE models: language

### How NIMBLE is the same as BUGS and JAGS

* Most distributions and functions are supported

    - For distributions, see [User Manual Section 5.2.4](http://r-nimble.org/manuals/NimbleUserManual.pdf#page=39) and our [cheatsheet](https://r-nimble.org/cheatsheets/NimbleCheatSheet.pdf)
    - For functions, see  [User Manual Section 5.2.5](http://r-nimble.org/manuals/NimbleUserManual.pdf#page=44)
  
* Most syntax is supported

    - Truncation syntax is different when using `nimbleCode`.  (It can
      be the same as for JAGS if reading code from a file with `readBUGSmodel()`).

See our [guide online](https://r-nimble.org/quick-guide-for-converting-from-jags-or-bugs-to-nimble).

---
# How NIMBLE extends BUGS

  - Alternative distribution parameterizations (like R).
  - Named parameters (like R).
  - Vectorized math (e.g., `pred[1:5] &lt;- b0 + b1*x[1:5]`) and linear algebra.
  - Definition-time if-then-else (multiple model variants from the same code).
  - User-defined functions and distributions.
  - Distinction between `constants` and `data`.

### How NIMBLE is limited compared to BUGS and/or JAGS:

NIMBLE is stricter about requiring square brackets and
   informative indices for non-scalar nodes.

---

# R-like alternative and named parameters


```r
littersCode &lt;- nimbleCode({
  for (i in 1:G) {
     for (j in 1:N) {
      # likelihood (data model)
        r[i,j] ~ dbin(p[i,j], n[i,j])
    # latent process (random effects)
        p[i,j] ~ dbeta(a[i], b[i]) 
     }
     # prior for hyperparameters
      a[i] ~ dgamma(shape = 1, `rate` = .001) 
      b[i] ~ dgamma(shape = 1, `scale` = 1/.001)
   }
})
```

Note that we could have used the mean/sd parameterization of the beta distribution, which would then require different hyperparameter specification.

---

# R-like alternative and named parameters

- BUGS/JAGS: Only `dnorm(mu, tau)` is supported, where `tau` is precision.
- NIMBLE: Alternative parameterizations and named parameters are supported:

    - `dnorm(mean = mu, sd = sigma)`
    - `dnorm(mean = mu, var = sigma_squared)`
    - `dnorm(mean = mu, tau = phi)` 
    
- Distributions with alternative parameterizations are listed in Table 5.2 of [User Manual Section 5.2.4](https://r-nimble.org/html_manual/cha-writing-models.html#subsec:dists-and-functions)

---
## What are constants? What are data?

### Constants are values needed to define model relationships

 - Index ranges like *N* in the litters model
 - Constant vectors used for indexing: e.g., *block* in `mu[block[i]]`
 - Constants must be provided when creating a model with `nimbleModel`.

### Data represents a flag on the role a node plays in the model

- E.g., data nodes shouldn't be sampled in MCMC.
- Data values can be changed.
- Data can be provided when calling `nimbleModel` or later

---

Here's an example:





```r
littersModel$isData('r')
```

```
##  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE
## [31] TRUE TRUE
```

```r
littersModel$isData('p')
```

```
##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [14] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [27] FALSE FALSE FALSE FALSE FALSE FALSE
```

```r
littersModel$r
```

```
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
## [1,]    4    4    3    0    1    4    0    3    5     5     1     1     1     0
## [2,]    2   10    3    4    8    6    7    7    7     1     4     0     8     2
##      [,15] [,16]
## [1,]     1     0
## [2,]     9     5
```

```r
littersModel$p
```

```
##           [,1]      [,2]      [,3]      [,4]      [,5]       [,6]      [,7]
## [1,] 0.7392769 0.5884470 0.7736998 0.5584487 0.7712720 0.52503569 0.4701040
## [2,] 0.7221339 0.6639406 0.7458808 0.7124073 0.5210273 0.06657146 0.6707607
##           [,8]      [,9]     [,10]     [,11]     [,12]     [,13]     [,14]
## [1,] 0.6827429 0.2933844 0.5457954 0.7383941 0.9402677 0.3821360 0.6337353
## [2,] 0.4841694 0.4561155 0.1392273 0.3669903 0.6166486 0.8403967 0.4710227
##          [,15]     [,16]
## [1,] 0.6281569 0.4237059
## [2,] 0.6083624 0.4848245
```

---
Data values are protected from simulation unless you are sure you want to simulate those 


```r
littersModel$simulate('r')
```

```
## NULL
```

```r
littersModel$simulate('p') 
littersModel$r
```

```
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
## [1,]    4    4    3    0    1    4    0    3    5     5     1     1     1     0
## [2,]    2   10    3    4    8    6    7    7    7     1     4     0     8     2
##      [,15] [,16]
## [1,]     1     0
## [2,]     9     5
```

```r
littersModel$p
```

```
##           [,1]      [,2]      [,3]       [,4]      [,5]      [,6]       [,7]
## [1,] 0.3938436 0.3858092 0.2681662 0.04971656 0.3024313 0.3333385 0.09661735
## [2,] 0.2061790 0.8540951 0.3972566 0.22504304 0.6575415 0.4619439 0.48893163
##           [,8]      [,9]     [,10]     [,11]      [,12]     [,13]      [,14]
## [1,] 0.1192609 0.5060517 0.5140213 0.1565768 0.08643474 0.2851147 0.07213901
## [2,] 0.6889330 0.5078989 0.2973866 0.5531423 0.08833924 0.8598639 0.54317045
##          [,15]     [,16]
## [1,] 0.1495059 0.1616713
## [2,] 0.9508988 0.6322957
```
---
Data values are protected from simulation unless you are sure you want to simulate those 


```r
littersModel$simulate('r', includeData = TRUE)
littersModel$r
```

```
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
## [1,]    4    4    3    0    1    4    0    3    5     5     1     1     1     0
## [2,]    2   10    3    4    8    6    7    7    7     1     4     0     8     2
##      [,15] [,16]
## [1,]     1     0
## [2,]     9     5
```
---

### Providing data and constants together.

- Data and constants can be provided together **as `constants`**.

- It would be slightly easier for BUGS/JAGS users to call this "data", but that would blur the concepts.  

- NIMBLE will usually disambiguate data when it is provided as constants.

---
### What are covariates and other non-parameters/non-observations?

- Covariates/predictors are examples of values that are not parameters nor data in the sense of the likelihood.

- Covariates/predictors can be provided via `constants` if you don't need to change them (often the case).

- Covariates/predictors can be provided via `data` or `inits` if you want to change them.

- NIMBLE will not treat them as 'data nodes'.

---
### More explicit need to provide dimensions 
### (in models, not in nimbleFunctions)

- Square brackets must always be provided to indicate number of dimensions

    - If `x` is 2-dimensional, use `x[,] %*% beta[]`, not `x %*% beta`
    
- Sometimes NIMBLE is not as smart as BUGS/JAGS at determining dimensions.  There are two solutions:

    - Give dimensions explicitly: `x[1:n, 1:m]`, OR
    
    - Provide a `dimensions` argument to `nimbleModel`. 
    Example: `dimensions = list(x = c(n, m))`.

---

# Vectorized math and linear algebra

Instead of writing this in your model code:


```r
nimbleOptions(verbose = FALSE)
m1 &lt;- nimbleModel(
    nimbleCode({
        for(i in 1:5) {
            predicted[i] &lt;- beta0 + beta1 * x[i]
        }
    }
    ))
```
you can write this:

```r
m2 &lt;- nimbleModel(
    nimbleCode({
        predicted[1:5] &lt;- beta0 + beta1 * x[1:5]
    }
    ))
```

---

&lt;svg viewBox="0 0 512 512" style="height:1em;position:relative;display:inline-block;top:.1em;fill:darkred;" xmlns="http://www.w3.org/2000/svg"&gt;  &lt;path d="M504 256c0 136.997-111.043 248-248 248S8 392.997 8 256C8 119.083 119.043 8 256 8s248 111.083 248 248zm-248 50c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"&gt;&lt;/path&gt;&lt;/svg&gt; They are not equivalent:


```r
## m1 has 5 scalar nodes
m1$getNodeNames()
```

```
## [1] "predicted[1]" "predicted[2]" "predicted[3]" "predicted[4]" "predicted[5]"
```

```r
## m2 has 1 vector node
m2$getNodeNames()
```

```
## [1] "predicted[1:5]"
```

One is not necessarily better than the other.  It depends on the model
and the MCMC configuration.  (More on those topics later.)

Vectorized declarations do not work for distributions.

---

### Be careful about scalar vs. vector vs. matrix vs. array

This will not work:

```r
x[1:5] &lt;- A[1:5, 1:5] %*% b[1:5] + c[1:5]
```

The problem is that the right-hand-side returns a matrix, so we can't assign it to a vector.

This will work:

```r
x[1:5] &lt;- (A[1:5, 1:5] %*% b[1:5] + c[1:5])[,1]
```

---
# Definition-time if-then-else

  - If you wish to define multiple alternative models in one set of code,
  you can use if-then-else statements.  
  
  - These will be evaluated based on variables in the R environment when the model is defined. 
  
  - **You cannot use if statements as statements within model code apart from this usage of defining alternative models.**

---
# Definition-time if-then-else

For example:


```r
code &lt;- nimbleCode({
    sigma ~ dunif(0, 10)
    beta0 ~ dnorm(0, sd = 1000)
    beta1 ~ dnorm(0, sd = 1000)
    if(INCLUDE_X2) { beta2 ~ dnorm(0, sd = 1000) } else {}
    for(i in 1:10) {
        if(INCLUDE_X2) {
            y[i] ~ dnorm(beta0 + beta1 * x1[i] + beta2 * x2[i], sd = sigma)
        } else {
            y[i] ~ dnorm(beta0 + beta1 * x1[i], sd = sigma)
        }
    }
})

INCLUDE_X2 &lt;- FALSE
m1 &lt;- nimbleModel(code)
INCLUDE_X2 &lt;- TRUE
m2 &lt;- nimbleModel(code)
```


```r
m1$getNodeNames()
m2$getNodeNames()
```

m2 has `beta2` while m1 does not.  The long names are "lifted nodes" -- more on those later.

---

# NIMBLE models: operating with models

### Models are graphs

- Scientists in many application domains and many statisticians speak of "hierarchical models".
- Computer scientists and others sometimes speak of "graphical models".
- A hierarchical model is typically a directed acyclic graph (DAG).

--

### Models are objects

When you create a NIMBLE model, it is an object in R. You can:

 - Get or set parameter or data values.
 - Determine graph relationships.
 - Calculate log probabilities.
 - Simulate (draw) from distributions.
 - More.
 
---
# Linear regression example

Let's use a really simple model:

- Linear regression with 4 data points.


```r
set.seed(1)
code &lt;- nimbleCode({
  intercept ~ dnorm(0, sd = 1000)
  slope ~ dnorm(0, sd = 1000)
  sigma ~ dunif(0, 100)
  for(i in 1:4) {
    predicted.y[i] &lt;- intercept + slope * x[i]
    y[i] ~ dnorm(predicted.y[i], sd = sigma)
  }
})
model &lt;- nimbleModel(code, 
                     data = list(y = rnorm(4)),
                     inits = list(intercept = 0.5, 
                                  slope = 0.2, 
                                  sigma = 1,
                                  x = c(0.1, 0.2, 0.3, 0.4)))
```

`x` values are neither observations ('data') nor parameters. `x` can also be provided in `constants` (this is generally best, unless you plan to change `x`) or in `data` (for consistency with WinBUGS/JAGS).

---
## Draw the graph

![](nimble_models_files/figure-html/linmodel-graph-1.png)&lt;!-- --&gt;


![](nimble_models_files/figure-html/linmodel-graph-1.png)

- Think of each line of BUGS language code as declaring one or mode *nodes*.


---

### Operating the models: values in the model

What's the current value in a variable?



```r
littersModel$r  
```

```
##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
## [1,]    4    4    3    0    1    4    0    3    5     5     1     1     1     0
## [2,]    2   10    3    4    8    6    7    7    7     1     4     0     8     2
##      [,15] [,16]
## [1,]     1     0
## [2,]     9     5
```

```r
littersModel$a[1]
```

```
## [1] 1
```

```r
littersModel$p
```

```
##           [,1]      [,2]      [,3]       [,4]      [,5]      [,6]       [,7]
## [1,] 0.3938436 0.3858092 0.2681662 0.04971656 0.3024313 0.3333385 0.09661735
## [2,] 0.2061790 0.8540951 0.3972566 0.22504304 0.6575415 0.4619439 0.48893163
##           [,8]      [,9]     [,10]     [,11]      [,12]     [,13]      [,14]
## [1,] 0.1192609 0.5060517 0.5140213 0.1565768 0.08643474 0.2851147 0.07213901
## [2,] 0.6889330 0.5078989 0.2973866 0.5531423 0.08833924 0.8598639 0.54317045
##          [,15]     [,16]
## [1,] 0.1495059 0.1616713
## [2,] 0.9508988 0.6322957
```

---

Setting values:


```r
littersModel$a[1] &lt;- 5
littersModel$a
```

```
## [1] 5 2
```

---

### Operating the model: *simulate()*
 
We have control over the model. In particular, for every node, NIMBLE provides **`calculate()`** and **`simulate()`** functions that calculate the current probability density value for the node and simulate a new value for the node from its (prior) distribution (i.e., given only parent nodes). These operations lie at the heart of many algorithms.

**`simulate()`** puts new values into the model; if you want to see those values, you need to look into the model.
.scroll-output[

```r
set.seed(1)  # so the calculations are reproducible
littersModel$simulate('p')  # simulate from prior
littersModel$p
```

```
##           [,1]      [,2]      [,3]      [,4]      [,5]       [,6]      [,7]
## [1,] 0.7392769 0.5884470 0.7736998 0.5584487 0.7712720 0.52503569 0.4701040
## [2,] 0.7221339 0.6639406 0.7458808 0.7124073 0.5210273 0.06657146 0.6707607
##           [,8]      [,9]     [,10]     [,11]     [,12]     [,13]     [,14]
## [1,] 0.6827429 0.2933844 0.5457954 0.7383941 0.9402677 0.3821360 0.6337353
## [2,] 0.4841694 0.4561155 0.1392273 0.3669903 0.6166486 0.8403967 0.4710227
##          [,15]     [,16]
## [1,] 0.6281569 0.4237059
## [2,] 0.6083624 0.4848245
```

```r
littersModel$getLogProb('p')  # log prob not yet updated!
```

```
## [1] -13.53032
```

```r
littersModel$calculate('p')   # update it
```

```
## [1] 8.753682
```

```r
littersModel$getLogProb('p')  # now we're good
```

```
## [1] 8.753682
```
]
---

# Operating the model: *calculate()* 

Let's change values in the model and recalculate the density values. NIMBLE sometimes introduces hidden nodes not specified in the model, so when calculating model density values, it's best to ask NIMBLE to do so based on the dependencies of the altered node.


```r
littersModel$getLogProb('p')
```

```
## [1] 8.753682
```

```r
littersModel$a[1] &lt;- 1
littersModel$b[1] &lt;- 3
littersModel$getLogProb('p')  # recall why this hasn't changed yet
```

```
## [1] 8.753682
```

```r
## DON'T DO THIS! (though it's ok to do here...)
## littersModel$calculate('p')

## INSTEAD DO THIS
deps &lt;- littersModel$getDependencies(c('a[1]','b[1]'))
littersModel$calculate(deps)
```

```
## [1] -29.96152
```

```r
## alternatively, we could just update the entire model to be safe:
## littersModel$calculate()

## now that model state is updated, can ask for logProbs
littersModel$getLogProb('p')
```

```
## [1] -13.53032
```



---
### Small recap

 - **data**: a known quantity in a model, also represented as a random variable, e.g., `r[1,1], r[1,2], ...` in the litters model
 
 - **constants**: other fixed quantities involved in the model, e.g., `N` in the litters model
 
 - **node**: an element in the model graph representing data, parameter, or a deterministic quantity that is a function of other quantities in the model, e.g. `a[1]`, `a[2]`, and `r[1, 2]` in the litters model
    - nodes can be univariate or multivariate depending on whether they ae defined based on a joint (multivariate) density or joint assignment
    
 - **variable**: a collection of one or more nodes with the same name, e.g., 'a' or 'r' in the litters model
 
---

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightSpans": true,
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
